c++11之前初始化变量方法是用赋值运算符：

```c++
int i = 1;
float f(2.4);
double d = double(2);
int ia[2] = {1, 2};
```

c++11提供了统一的初始化变量方法，即列表初始化：

```c++
int i{1};
double d{2.0};
char c[3]{'a', 'b', 'c'};
vector<string> vs{"a", "b", "c"};
```

如果一个变量没有使用显式的{}，那么其初始值是未定义的：

```c++
int i; // 未定义其初始值
int i;{} // 初始值是0
char *p; // 未定义
char *p{}; // 初始值为nullptr
```

使用{}初始化方法还有一个好处：防止变量类型收窄！意思是减少了隐式的类型转换：

```c++
int i(1.2); // i = 1
int i = 1.2; // i = 1
int i{1.2}; // build error
```

那么自定义的类型如何初始化呢？也可以用{}：

```c++
class A
{
    int _i, _j;
public:
    A(int i, int j) : _i(i), _j(j){}
};

A a(1, 2); // 显式A(int,int)构造函数
A a{1, 2}; // ok,列表初始化,也调用A(int,int)构造函数
A a = {1, 2} // ok,列表初始化,也调用A(int,int)构造函数
```

从以上来看，列表初始化是好处多多啊！但是其使用也有需要注意的地方，那就是非聚合类型不能用列表初始化方法。

聚合类型定义：

- 任意类型的数组

- 满足以下条件的类

  - 没有自定义的构造函数
  - 没有私有或保护的非static成员变量
  - 没有基类
  - 没有虚函数
  - 没有通过=或{}在类声明时被初始化的非static成员变量

聚合类型利用列表初始化进行初始化，编译器会对各个元素逐一赋值。