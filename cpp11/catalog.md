# 第1章　使用C++11让程序更简洁、更现代 2

1.1　类型推导 2

 1.1.1　auto类型推导 2

 1.1.2　decltype关键字 9

 1.1.3　返回类型后置语法——auto和decltype的结合使用 14

1.2　模板的细节改进 16

 1.2.1　模板的右尖括号 16

 1.2.2　模板的别名 18

 1.2.3　函数模板的默认模板参数 20

1.3　列表初始化 22

 1.3.1　统一的初始化 23

 1.3.2　列表初始化的使用细节 25

 1.3.3　初始化列表 29

 1.3.4　防止类型收窄 32

1.4　基于范围的for循环 34

 1.4.1　for循环的新用法 34

 1.4.2　基于范围的 for循环的使用细节 36

 1.4.3　让基于范围的 for循环支持自定义类型 40

1.5　std::function和bind绑定器 47

 1.5.1　可调用对象 47

 1.5.2　可调用对象包装器——std::function 49

 1.5.3　std::bind绑定器 52

1.6　lambda表达式 56

 1.6.1　lambda表达式的概念和基本用法 56

 1.6.2　声明式的编程风格，简洁的代码 59

 1.6.3　在需要的时间和地点实现闭包，使程序更灵活 60

1.7　tupe元组 61

1.8　总结 63

# 第2章　使用C++11改进程序性能 64

2.1　右值引用 64

 2.1.1　&&的特性 65

 2.1.2　右值引用优化性能，避免深拷贝 71

2.2　move语义 77

2.3　forward和完美转发 78

2.4　emplace_back减少内存拷贝和移动 81

2.5　unordered container无序容器 83

2.6　总结 85

# 第3章　使用C++11消除重复，提高代码质量 86

3.1　type_traits——类型萃取 86

 3.1.1　基本的type_traits 87

 3.1.2　根据条件选择的traits 96

 3.1.3　获取可调用对象返回类型的traits 96

 3.1.4　根据条件禁用或启用某种或某些类型traits 99

3.2　可变参数模板 103

 3.2.1　可变参数模板函数 103

 3.2.2　可变参数模板类 107

 3.2.3　可变参数模板消除重复代码 111

3.3　可变参数模版和type_taits的综合应用 114

 3.3.1　optional的实现 114

 3.3.2　惰性求值类lazy的实现 118

 3.3.3　dll帮助类 122

 3.3.4　lambda链式调用 126

 3.3.5　any类的实现 128

 3.3.6　function_traits 131

 3.3.7　variant的实现 134

 3.3.8　ScopeGuard 140

 3.3.9　tuple_helper 141

3.4　总结 153

# 第4章　使用C++11解决内存泄露的问题 155

4.1　shared_ptr共享的智能指针 155

 4.1.1　shared_ptr的基本用法 156

 4.1.2　使用shared_ptr需要注意的问题 157

4.2　unique_ptr独占的智能指针 159

4.3　weak_ptr弱引用的智能指针 161

 4.3.1　weak_ptr基本用法 161

 4.3.2　weak_ptr返回this指针 162

 4.3.3　weak_ptr解决循环引用问题 163

4.4　通过智能指针管理第三方库分配的内存 164

4.5　总结 166

# 第5章　使用C++11让多线程开发变得简单 167

5.1　线程 167

 5.1.1　线程的创建 167

 5.1.2　线程的基本用法 170

5.2　互斥量 171

 5.2.1　独占互斥量std::mutex 171 

 5.2.2　递归互斥量std::recursive_mutex 172

 5.2.3　带超时的互斥量std::timed_mutex和std::recursive_timed_mutex 174

5.3　条件变量 175

5.4　原子变量 179

5.5　call_once/once_flag的使用 180

5.6　异步操作 181

 5.6.1　获取线程函数返回值的类std::future 181

 5.6.2　协助线程赋值的类 std::promise 182

 5.6.3　可调用对象的包装类std::package_task 182

 5.6.4　std::promise、std::packaged_task和std::future三者之间的关系 183

5.7　线程异步操作函数async 184

5.8　总结 185

# 第6章　使用C++11中便利的工具 186

6.1　处理日期和时间的chrono库 186

 6.1.1　记录时长的duration 186

 6.1.2　表示时间点的time point 188

 6.1.3　获取系统时钟的clocks 190

 6.1.4　计时器timer 191

6.2　数值类型和字符串的相互转换 193

6.3　宽窄字符转换 195

6.4　总结 196

# 第7章　C++11的其他特性 197

7.1　委托构造函数和继承构造函数 197

 7.1.1　委托构造函数 197

 7.1.2　继承构造函数 199

7.2　原始的字面量 201

7.3　final和override关键字 203

7.4　内存对齐 204

 7.4.1　内存对齐介绍 204

 7.4.2　堆内存的内存对齐 207

 7.4.3　利用alignas指定内存对齐大小 207

 7.4.4　利用alignof和std::alignment_of获取内存对齐大小 208

 7.4.5　内存对齐的类型std::aligned_storage 209

 7.4.6　std::max_align_t和std::align操作符 211

7.5　C++11新增的便利算法 211

7.6　总结 216